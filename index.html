<!DOCTYPE html>

<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <script type="module" src="./elevation-profile.ts"></script>
    <style>
      body {
        margin: 0;
      }
      .container {
        position: relative;
        margin: 50px;
      }

      #tooltip {
        display: none;
        position: absolute;
        background-color: #707070;
        color: #fff;
        padding: 10px;
        transform: translate(-50%, -100%);
      }

      elevation-profile {
        display: block;
        width: 80%;
        height: 300px;
      }

      elevation-profile .grid.x {
        display: none;
      }

      elevation-profile line {
        shape-rendering: crispEdges;
      }

      elevation-profile .axis .domain, .grid .domain {
        display: none;
      }

      elevation-profile .axis line, .grid line {
        stroke: #707070;
      }

      elevation-profile .pointer-line {
        stroke: #707070;
        stroke-opacity: 0.3;
        stroke-width: 2;
        stroke-dasharray: 3, 3;
      }

      elevation-profile .pointer-circle {
        fill: #3761a4;
        stroke: #fff;
        stroke-width: 3;
      }
      elevation-profile .pointer-circle-outline {
        fill: #000;
        fill-opacity: 0.2;
      }

      elevation-profile .elevation, elevation-profile .elevation.highlight {
        stroke: #3761a4;
        stroke-width: 2;
        stroke-linejoin: round;
      }
      elevation-profile .elevation.highlight {
        stroke-width: 3;
      }

      elevation-profile .area {
        fill: #e6e6e6;
        fill-opacity: 0.85;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="tooltip"></div>

      <elevation-profile></elevation-profile>
    </div>
    <button id="set-lines">set lines</button>
    <button id="reset-lines">reset lines</button>
    <button id="save">save</button>

    <pre id="logs"></pre>

    <script>
      const profile = document.querySelector("elevation-profile");
      const tooltip = document.querySelector("#tooltip");
      const logs = document.querySelector("#logs");
      const setLines = document.querySelector("#set-lines");
      const resetLines = document.querySelector("#reset-lines");
      const save = document.querySelector("#save");

      profile.updateScale = (x, y, width, height) => {
        // Flattened array of [xMax,ratioYOverX].
        const ratiosXY = [0, 0.5, 0.33, 0.2, 0.1, 0.05];
        const ratiosMinDist = [0, 2000, 5000, 20000, 100000, Infinity];
        console.assert(ratiosXY.length === ratiosMinDist.length);

        let i;

        const xDomain = x.domain();

        let yDomain = y.domain();

        // Add padding to Y domain
        const padding = (yDomain[1] - yDomain[0]) * 0.1;
        y.domain([yDomain[0] - padding, yDomain[1] + padding]);
        yDomain = y.domain();

        const xMin = xDomain[0];
        const xMax = xDomain[1];
        const yMin = yDomain[0];
        let yMax = yDomain[1];

        // Search for the best XY ratio
        let yDomainLength = 0;
        i = 0;
        let reverse = false;
        // The algorithm is:
        // - advance to reach the expected ratio;
        // - if the computed ydomain would not be large enough, reverse direction;
        // - go backwards until a good ydomain is found;
        // - if none is found keep the ydomain values from d3.
        while (true) {
          if (!reverse && xMax > ratiosMinDist[i]) {
            // advance in the ratio table
            ++i;
            continue;
          }

          const ratioYOverX = ratiosXY[i];
          const xResolution = (xMax - xMin) / width;
          yDomainLength = ratioYOverX * xResolution * height;

          if (i > 0 && yDomainLength < yMax - yMin) {
            // not enough space with this ratio to show all the
            // y values. Go back to try another ratio.
            reverse = true;
            --i;
            continue;
          }

          break;
        }

        // Apply XY ratio
        if (yDomainLength) {
          const yMean = (yMax + yMin) / 2;
          const yHalfDomain = yDomainLength / 2;
          y.domain([yMean - yHalfDomain, yMean + yHalfDomain]);
        }

        // Lower bound for y-axis
        if (y.domain()[0] < 0) {
          const shift = 0 - y.domain()[0];
          // For yLowerBound=0 and y0=-50, y is shifted 50m up
          y.domain([0, y.domain()[1] + shift]);
        }
      };

      save.addEventListener("click", () => {
        const svg = profile.innerHTML;
        const blob = new Blob([svg], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "elevation.svg";
        a.click();
      });

      setLines.addEventListener("click", () => {
        profile.lines = [
          [
            [740073, 5905947, 434, 0],
            [740073, 5905947, 485, 25],
            [740073, 5905947, 490, 60],
            [740072, 5905940, 512, 100],
          ],
          [
            [740007, 5905729, 490, 155],
            [740000, 5905709, 489, 169],
            [739997, 5905704, 501, 173],
            [739997, 5905704, 512, 180],
            [739997, 5905704, 501, 210],
          ], [
            [740007, 5905729, 512, 255],
            [740000, 5905709, 505, 369],
            [739997, 5905704, 501, 390],
          ]
        ];
      });

      resetLines.addEventListener("click", () => {
        profile.lines = [];
      });

      profile.addEventListener("over", (event) => {
        logs.textContent = JSON.stringify(event.detail, null, 2);
        tooltip.style.display = "block";
        tooltip.textContent = `${event.detail.coordinate[2]} m`;
        tooltip.style.left = `${event.detail.position.x}px`;
        tooltip.style.top = `${event.detail.position.y - 20}px`;
      });
      profile.addEventListener("out", (event) => {
        logs.textContent = "";
        tooltip.style.display = "none";
      });
    </script>
  </body>
</html>
